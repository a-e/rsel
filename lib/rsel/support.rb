#require File.join(File.dirname(__FILE__), 'exceptions')

require 'xpath'

module Rsel
  # Support functions for Rsel
  module Support

    # Convert the given locator to a format accepted by Selenium. If `locator`
    # starts with `id=`, `name=`, `dom=`, `xpath=` `link=` or `css=`, then the
    # locator is returned unchanged. Otherwise, `locator` is assumed to be a
    # plain string, and a Selenium-style `xpath=` locator is returned, matching
    # HTML elements of the given kind, in the given scope. This allows you to
    # use simple human-readable locator strings, or more specific
    # Selenium-style locators.
    #
    # @param [String] locator
    #   A Selenium-style locator beginning with `id=`, `name=`, `dom=`,
    #   `xpath=`, `link=` or `css=`, or a plain text string that will
    #   automatically match on the `id`, `name`, label, value, or text content
    #   depending on the value of `kind`.
    # @param [String] kind
    #   What kind of locator you're using (link, button, checkbox, field etc.).
    #   This must correspond to a method name in `XPath::HTML`. If you're using
    #   a raw Selenium-style `locator` string, this argument can be omitted.
    # @param [Hash] scope
    #   Keywords to restrict the scope of matching elements. Ignored when
    #   a Selenium-style locator is used. See the {#xpath} documentation for
    #   allowed options.
    #
    def loc(locator, kind='', scope={})
      if locator.empty?
        raise ArgumentError, "locator is required."
      elsif locator =~ /^(id=|name=|dom=|xpath=|link=|css=)/
        return locator
      else
        return xpath(kind, locator, scope)
      end
    end


    # Return a Selenium-style xpath generated by calling `XPath::HTML.<kind>`
    # with the given `locator`. If `scope` options are provided, the xpath is
    # modified accordingly, to match only elements in the given scope.
    #
    # @param [String] kind
    #   What kind of locator you're using (link, button, checkbox, field etc.).
    #   This must correspond to a method name in `XPath::HTML`.
    # @param [String] locator
    #   Name, id, value, label or whatever other locators are accepted by
    #   `XPath::HTML.<kind>`
    # @param [Hash] scope
    #   Keywords to restrict the scope of matching elements
    # @option scope [String] :within
    #   Restrict scope to elements having this id, matching `locator` only if
    #   it's contained within an element with this id.
    # @option scope [String] :in_row
    #   Restrict scope to a table row containing this text, matching `locator`
    #   only if that locator is in the same row as the given text.
    #
    # @example
    #   xpath('link', 'Log in')
    #   xpath('button', 'Submit')
    #   xpath('field', 'First name')
    #   xpath('table_row', ['First', 'Last'])
    #
    def xpath(kind, locator, scope={})
      if !XPath::HTML.respond_to?(kind)
        raise ArgumentError, "Unknown kind of locator: '#{kind}'"
      end
      loc_xp = XPath::HTML.send(kind, locator)
      if scope[:within]
        parent = XPath.descendant[XPath.attr(:id).equals(scope[:within])]
        result = apply_scope(parent, loc_xp)
      elsif scope[:in_row]
        row = XPath.descendant(:tr)[XPath.contains(scope[:in_row])]
        result = apply_scope(row, loc_xp)
      else
        result = loc_xp.to_s
      end
      return "xpath=#{result}"
    end


    # Restrict the scope of all XPath expressions in `inner` by prepending
    # `container` to each of them, and return new union expression where
    # `inner` matches only if it's a child of `container`.
    #
    def apply_scope(container, inner)
      scoped_expressions = xpath_expressions(inner).collect do |expr|
        container.child(expr)
      end
      return XPath::Union.new(*scoped_expressions).to_s
    end


    # Return an array of individual Expressions in the given XPath::Union, or
    # just `[union]` if it has no sub-expressions. This is an ugly recursive
    # hack, designed to allow splitting up unions into their constituents for
    # the purpose of modifying them individually and re-combining them.
    #
    # @param [XPath::Union, XPath::Expression] union
    #   The xpath you want to break down into individual expressions
    #
    # @since 0.0.3
    #
    def xpath_expressions(union)
      if union.respond_to?(:expressions)
        return union.expressions.collect do |expr|
          xpath_expressions(expr)
        end.flatten
      else
        return [union]
      end
    end


    # Escape certain characters to generate characters that can't otherwise be
    # used in FitNesse hashtables.
    #
    # * \; becomes :
    # * \' becomes ,
    # * \[ becomes {
    # * \] becomes }
    # * \\ becomes \
    #
    # @since 0.1.1
    #
    def escape_for_hash(text)
      # ((?:\\\\)*) allows any extra pairs of "\"s to be saved.
      text = text.gsub(/(^|[^\\])\\((?:\\\\)*);/, '\1\2:')
      text = text.gsub(/(^|[^\\])\\((?:\\\\)*)'/, '\1\2,')
      text = text.gsub(/(^|[^\\])\\((?:\\\\)*)\[/, '\1\2{')
      text = text.gsub(/(^|[^\\])\\((?:\\\\)*)\]/, '\1\2}')
      text = text.gsub(/\\\\/, '\\')
      return text
    end


    # Normalize the given hash of name => locator mappings.
    # Converts all keys to lowercase and calls {#escape_for_hash} on them.
    #
    def normalize_ids(ids)
      ids = {} unless ids.is_a? Hash
      ids.keys.each do |key|
        new_key = escape_for_hash(key.to_s.downcase)
        new_value = escape_for_hash(ids[key])
        ids[new_key] = new_value

        # Delete the old key if necessary
        if new_key != key
          ids.delete(key)
        end
      end
    end


    # Strip HTML tags from the given text. This can be used for converting
    # URLs that FitNesse has marked up back into plain URLs.
    #
    # @param [String] text
    #   Text, possibly including markup, that you want to strip
    #
    # @since 0.1.1
    #
    def strip_tags(text)
      return text.gsub(/<\/?[^>]*>/, '')
    end

  end
end

