#require File.join(File.dirname(__FILE__), 'exceptions')

require 'xpath'

module Rsel
  # Support functions for Rsel
  module Support

    # Convert the given locator to a format accepted by Selenium. If `locator`
    # starts with `id=`, `name=`, `dom=`, `xpath=` `link=` or `css=`, then the
    # locator is returned unchanged. Otherwise, `locator` is assumed to be a
    # plain string, and a Selenium-style `xpath=` locator is returned, matching
    # HTML elements of the given kind, in the given scope. This allows you to
    # use simple human-readable locator strings, or more specific
    # Selenium-style locators.
    #
    # @param [String] locator
    #   A Selenium-style locator beginning with `id=`, `name=`, `dom=`,
    #   `xpath=`, `link=` or `css=`, or a plain text string that will
    #   automatically match on the `id`, `name`, label, value, or text content
    #   depending on the value of `kind`.
    # @param [String] kind
    #   What kind of locator you're using (link, button, checkbox, field etc.).
    #   This must correspond to a method name in `XPath::HTML`. If you're using
    #   a raw Selenium-style `locator` string, this argument can be omitted.
    # @param [Hash] scope
    #   Keywords to restrict the scope of matching elements. Ignored when
    #   a Selenium-style locator is used. See the {#xpath} documentation for
    #   allowed options.
    #
    def loc(locator, kind='', scope={})
      if locator.empty?
        raise ArgumentError, "locator is required."
      elsif locator =~ /^(id=|name=|dom=|xpath=|link=|css=)/
        return locator
      else
        return xpath(kind, locator, scope)
      end
    end


    # Return a Selenium-style xpath generated by calling `XPath::HTML.<kind>`
    # with the given `locator`. If `scope` options are provided, the xpath is
    # modified accordingly, to match only elements in the given scope.
    #
    # @param [String] kind
    #   What kind of locator you're using (link, button, checkbox, field etc.).
    #   This must correspond to a method name in `XPath::HTML`.
    # @param [String] locator
    #   Name, id, value, label or whatever other locators are accepted by
    #   `XPath::HTML.<kind>`
    # @param [Hash] scope
    #   Keywords to restrict the scope of matching elements
    # @option scope [String] :within
    #   Restrict scope to elements having this id, matching `locator` only if
    #   it's contained within an element with this id.
    # @option scope [String] :in_row
    #   Restrict scope to a table row containing this text, matching `locator`
    #   only if that locator is in the same row as the given text.
    #
    # @example
    #   xpath('link', 'Log in')
    #   xpath('button', 'Submit')
    #   xpath('field', 'First name')
    #   xpath('table_row', ['First', 'Last'])
    #
    def xpath(kind, locator, scope={})
      if !XPath::HTML.respond_to?(kind)
        raise ArgumentError, "Unknown kind of locator: '#{kind}'"
      end
      loc_xp = XPath::HTML.send(kind, locator)
      if scope[:within]
        parent = XPath.descendant[XPath.attr(:id).equals(scope[:within])]
        result = apply_scope(parent, loc_xp)
      elsif scope[:in_row]
        row = XPath.descendant(:tr)[XPath.contains(scope[:in_row])]
        result = apply_scope(row, loc_xp)
      else
        result = loc_xp.to_s
      end
      return "xpath=#{result}"
    end


    # Restrict the scope of all XPath expressions in `inner` by prepending
    # `container` to each of them, and return new union expression where
    # `inner` matches only if it's a child of `container`.
    #
    def apply_scope(container, inner)
      scoped_expressions = xpath_expressions(inner).collect do |expr|
        container.child(expr)
      end
      return XPath::Union.new(*scoped_expressions).to_s
    end


    # Return an array of individual Expressions in the given XPath::Union, or
    # just `[union]` if it has no sub-expressions. This is an ugly recursive
    # hack, designed to allow splitting up unions into their constituents for
    # the purpose of modifying them individually and re-combining them.
    #
    # @param [XPath::Union, XPath::Expression] union
    #   The xpath you want to break down into individual expressions
    #
    # @since 0.0.3
    #
    def xpath_expressions(union)
      if union.respond_to?(:expressions)
        return union.expressions.collect do |expr|
          xpath_expressions(expr)
        end.flatten
      else
        return [union]
      end
    end
  end
end

